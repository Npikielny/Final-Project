from math import floor
def funcInterpreter(equation):
    print(equation)
    terms = (getOperandsAndTerms(equation))[0]
    operands = (getOperandsAndTerms(equation))[1]
    pren = prenEliminator(terms,operands)
    return(pren)
    

def prenEliminator(terms, operands):
    newTerms = []
    operators = []
    for z in terms:
        newTerms.append(z)
    for z in operands:
        operators.append(z)
    pp = 1
    g = 0
    while pp == 1 and g != 5:
        #print("while", newTerms)
        #print("pren:", newTerms)
        #print("pren:", operands)
        g += 1
        pcheck = ""
            
        for i in range(0,len(newTerms)):
            if str(newTerms[i]).isdigit() == False:
                p = str(newTerms[i]).count("(")
                if p == 1:
                    newTerms[i] = (newTerms[i])[1:len(newTerms[i])-1]
                    #print("calling newTerm", (getOperandsAndTerms(newTerms[i]))[0],(getOperandsAndTerms(newTerms[i]))[1])
                    newTerms[i] = str(funcSolver((getOperandsAndTerms(newTerms[i]))[0],(getOperandsAndTerms(newTerms[i]))[1]))
                    #print("newTerms", newTerms, newTerms[i])
                elif p > 1:
                    #print("Implementation needed")
                    term = ""
                    newTerm = ""
                    outside = ""
                    for k in newTerms[i]:
                        term += k
                        if k == "(":
                            outside += term[0:len(term)-1:]
                            term = "("
                        elif k == ")" and term[0] == "(":
                            term = term[1:len(term)-1:]
                            #print("calling newTerm", getOperandsAndTerms(term)[0],getOperandsAndTerms(term)[1])
                            #newTerm = str(funcSolver(getOperandsAndTerms(term))[0],getOperandsAndTerms(term)[1])
                            newTerm = str(funcSolver(getOperandsAndTerms(term)[0],getOperandsAndTerms(term)[1]))
                            outside += "{0}"
                            term = ""
                            outside = outside.format(newTerm)
                    outside += term
                    newTerms[i] = str(outside)
                    #print("newTerms[i]", newTerms[i])
        for h in newTerms:
            pcheck += str(h)
        if pcheck.count("(") == 0:
            pp = 0
    
    if len(newTerms) > 1:
        #print("final Solver")
        newTerms = funcSolver(newTerms, operands)
    #print("returning")
                #Solving Inner parenthetical Terms Like (4 + (3 + 2))
    #print(newTerms, g, "G", pp, ": PP", pcheck, pcheck.count("("))
    return(newTerms) 

def getOperandsAndTerms(equation):
    #initial Seperation
    terms = []
    term = ""
    operands = []
    p = 0
    op = 1
    for i in str(equation):
        if i != " " and i != "y" and i != "=":
            if i == "(":
                p += 1
            elif i == ")":
                p -= 1
            if p == 0 and i != ")":
                if i == "+" or i == "*" or i == "/" or i == "^":
                    operands.append(i)
                    op = 1
                    if term != "":
                        terms.append(term)
                        term = ""
                elif i == "-":
                    #Negative
                    if op == 1:
                        op = 2
                        term += i
                    else:
                        #minusOperator
                        operands.append(i)
                        op = 1
                        if term != "":
                            terms.append(term)
                            term = ""
                elif i.isdigit() == True:
                    term += i
                    op = 0
                elif i.isdigit() == False:
                    if term != "":
                        terms.append(term)
                        term = ""
                        op = 0
                    terms.append(i)
                if len(terms) > len(operands) + 1:
                    operands.append("*")
                    op = 1
            else:
                term += i
    if term != "":
        terms.append(term)
    #print("GottenTerms", terms, "GottenOperands", operands, "from", equation)
    return((terms,operands))
    
def funcSolver(terms, operands):
    #print("funcSolverCalled")
    #print("terms:", terms)
    #print("operands:", operands)
    newTerms = terms
    final = 0
    holder = ""
    if len(operands) > 0:
        for i in range(0,len(operands)):
            if operands[i] == "^":
                newTerms[i] = int(terms[i])**int(terms[i+1])
                del newTerms[i+1]
        #print("expo:", newTerms)
        for i in range(0,len(operands)):
            if operands[i] == "*":
                newTerms[i] = int(terms[i])*int(terms[i+1])
                del newTerms[i+1]
            elif operands[i] == "/":
                newTerms[i] = int(terms[i])/int(terms[i+1])
                del newTerms[i+1]
        #print("mult:", newTerms)
        for i in range(0,len(operands)):
            if operands[i] == "-":
                newTerms[i+1] = str((-1)*int(terms[i+1]))
        #print("sub:", newTerms)
        for i in newTerms:
            #print("i", i)
            final += int(i)  
    else:
        final = ""
        for i in terms:
            for k in i:
                if k.isdigit() == True:
                    final += str(k)
        final = int(final)
    #print("solved", final)
    return(final)

print(funcInterpreter("y =3*((3)+(3))"))
#print(funcInterpreter("y=24+1/4^2"))
#print(funcSolver())
            
