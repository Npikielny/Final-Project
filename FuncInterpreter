
def funcInterpreter(equation):
    if equation.count("(") != equation.count(")") or equation.find("=") == 0:
        print("Invalid input given")
    else:
        newEquation = ""
        for i in equation:
            if i != " ":
                newEquation += i
        print("Interpreting:", newEquation)    
        #equationL = getOperandsAndTerms(newEquation[0:newEquation.find("=")+1])
        #equationR = getOperandsAndTerms(newEquation[newEquation.find("=") + 1:len(newEquation)])
        #print(equationR, "Left 'x': ", varSplitter(equationR[0], equationR[1], ["x"]))
        #print(equationL, "Right 'y': ", varSplitter(equationL[0], equationL[1], ["y"]))
        newEquation = getOperandsAndTerms(newEquation)
        print("FINISHED:",newEquation, varSplitter(newEquation[0], newEquation[1], ["x"]))
        #return(equationL, equationR)    
'''        
def funcType(equation):
    equationL = equation[0:equation.find("=")]
    equationR = equation[equation.find("=") + 1:len(equation)]
    yL = equationL.count("y") + equationL.count("Y")
    xL = equationL.count("x") + equationL.count("X")
    yR = equationR.count("y") + equationR.count("Y")
    xR = equationR.count("x") + equationR.count("X")
    if yL > 0 and xL+yR+xR == 0:
        return("y")
    elif xL > 0 and yL+xR+yR == 0:
        return("x")
    elif yL>0 and xR >0 and yR+xL == 0:
        return("y=x")
    elif xL>0 and yR >0 and yL+xR == 0:
        return("x=y")
    elif (xL > 0 and yL > 0) or (xR > 0 and yR > 0)
'''  
def funcCombiner(equation):
    #print(equation)
    equationL = getOperandsAndTerms(equation[0:equation.find("=")])
    #print(equationL)
    equationR = getOperandsAndTerms(equation[equation.find("="):len(equation)-1])
    #print(equationR)
    equationLOperators=[]
    for i in equationL[1]:
        if i == "-":
            equationLOperators.append("+")
        elif i == "+":
            equationLOperators.append("-")
        else:
            equationLOperators.append(i)
    return(equationR[0] + equationL[0],equationR[1] + equationLOperators[:])
    
'''    
def varSplitter(terms, operands, variables):
    varParts = ""
    intParts = ""
    newTerms = []
    newOperands = []
    term = 0
    shift = 0
    #CondensingTerms
    print(terms, operands)
    if len(operands)>0:
        for i in range(len(operands)):
            if operands[i] == "-":
                operands[i] = "+"
                terms[i+1] = "-" + terms[i+1]
        for i in range(len(operands)):
            if i < len(operands):
                print(newTerms,newOperands)
                print(terms[i],operands[i])
                if operands[i] == "^" or operands[i] == "*" or operands[i] == "/":
                    if term == 0:
                        newTerms.append(terms[i] + operands[i] + terms[i+1])
                        term = 1
                        print("Deleting:", terms[i+1], operands[i])
                        del terms[i+1]
                        del operands[i]
                        print(terms, operands)
                    else:
                        newTerms[len(newTerms)-1] = newTerms[len(newTerms)-1] + operands[i] + terms[i + 1]
                else:
                    term = 0
                   # if operands[i] == "+":
                    newTerms.append(terms[i])
                    newOperands.append(operands[i])
    else:
        newTerms = terms
    print("new", newTerms, newOperands)
    #TermsAreNowCondensed
    for i in range(len(newOperands)):
        if newOperands[i] == "-":
            newOperands[i] = "+"
            newTerms[i] = "-" + newTerms[i]
        varsFound = 0
        for k in variables:
            if newTerms[i].count(k) > 0:
                varsFound += 1
        if varsFound > 0:
            if len(varParts) > 0:
                varParts += "+" + newTerms[i]
            else:
                varParts += newTerms[i]
        elif len(intParts)>0:
            intParts += "+" + newTerms[i]
        else:
            intParts += newTerms[i]
    return(varParts, intParts)
'''               
      
def funcCompiler(terms, operands):
    output = ""
    for i in range(0, len(terms)):
        output += terms[i]
        if i < len(terms) - 1:
            output += operands[i]
    return(output)

def prenEliminator(terms, operands):
    newTerms = []
    operators = []
    for z in terms:
        newTerms.append(z)
    for z in operands:
        operators.append(z)
    pp = 1
    g = 0
    ##print("size?",newTerms,operators)
    while pp == 1 and g != 5:
        #print("while", newTerms, "g=", g)
        ##print("pren:", newTerms)
        ##print("pren:", operands)
        g += 1
        pcheck = ""
            
        for i in range(0,len(newTerms)):
            ##print("i", newTerms[i])
            if str(newTerms[i]).isdigit() == False:
                p = str(newTerms[i]).count("(")
                ##print("Implementation needed")
                term = ""
                newTerm = ""
                outside = ""
                for k in newTerms[i]:
                    ##print("k", k)
                    term += k
                    #print("length:", len(term[1:len(term)-1:]))
                    if k == "(":
                        outside += term[0:len(term)-1:]
                        if len(outside) > 0:
                            if outside[len(outside) - 1].isdigit() == True or outside[len(outside) - 1] == "x" or outside[len(outside) - 1] == "y":
                                outside += "*"
                        term = "("
                    elif k == ")" and term[0] == "(" and len(term[1:len(term)-1:]) > 0:
                        term = term[1:len(term)-1:]
                        ##print("calling newTerm", getOperandsAndTerms(term)[0],getOperandsAndTerms(term)[1])
                        #newTerm = str(funcSolver(getOperandsAndTerms(term))[0],getOperandsAndTerms(term)[1])
                        newTerm = str(funcSolver(getOperandsAndTerms(term)[0],getOperandsAndTerms(term)[1]))
                        outside += "{0}"
                        term = ""
                        outside = outside.format(newTerm)
                    elif k == ")" and term[0] == "(" and len(term[1:len(term)-1:]) == 0:
                        print("There is an empty term; Substituting 0")
                        term = ""
                        outside += "0"
                    ##print("term", term)
                ##print("final term", term)
                if len(term) > 0:
                    if term[0].isdigit() == True:
                        term = "*" + term
                    ##print("cash me", outside, term)
                    outside += term
                ##print(outside)
                newTerms[i] = str(outside)
                ##print("newTerms[i]", newTerms[i])
        for h in newTerms:
            pcheck += str(h)
        if pcheck.count("(") == 0:
            pp = 0
    
    if len(newTerms) > 1:
        ##print("final Solver")
        newTerms = funcSolver(newTerms, operands)
    ##print("returning")
                #Solving Inner parenthetical Terms Like (4 + (3 + 2))
    ##print(newTerms, g, "G", pp, ": PP", pcheck, pcheck.count("("))
    return(newTerms) 

def getOperandsAndTerms(equation):
    #initial Seperation
    terms = []
    term = ""
    operands = []
    p = 0
    op = 1
    for i in str(equation):
        if i != " " and i != "'"  and i != "[" and i != "]":
            if i == "(" or i == "{":
                p += 1
                if term != "" and term.count("(") == 0:
                    terms.append(term)
                    term = ""
                    op = 0
                elif op == 0:
                    operands.append("*")
            elif i == ")" or i == "}":
                p -= 1
            if p == 0 and i != ")" and i != "}":
                if i == "+" or i == "*" or i == "/" or i == "^":
                    operands.append(i)
                    op = 1
                    if term != "":
                        terms.append(term)
                        term = ""
                elif i == "-":
                    if op == 1:
                        op = 2
                        term += i
                    elif op == 2:
                        op = 0
                        term = term[0:len(term)-1]
                    else:
                        #minusOperator
                        operands.append(i)
                        op = 1
                        if term != "":
                            terms.append(term)
                            term = ""
                elif i.isdigit() == True or i == ".":
                    term += i
                    op = 0
                elif i.isdigit() == False:
                    if term != "":
                        terms.append(term)
                        term = ""
                        op = 0
                    terms.append(i)
                if len(terms) > len(operands) + 1:
                    operands.append("*")
                    op = 1
            elif p == 0 and (i == ")" or i == "}"):
                term += i
                terms.append(term)
                term = ""
                op = 0
            else:
                term += i
    if term != "":
        terms.append(term)
    ##print("GottenTerms", terms, "GottenOperands", operands, "from", equation)
    return((terms,operands))
    
def funcSolver(terms, operands):
    #print("funcSolverCalled")
    #print("terms:", terms)
    #print("operands:", operands)
    newTerms = terms
    final = 0
    holder = ""
    found = 0
    if len(operands) > 0:
        for i in range(0,len(operands)):
            i = i - found
            if operands[i] == "^":
                newTerms[i] = float(terms[i])**float(terms[i+1])
                del newTerms[i+1]
                del operands[i]
                found += 1
        #print("expo:", newTerms, operands)
        found = 0
        for i in range(0,len(operands)):
            i = i - found
            #print(i,len(terms),len(operands))
            #print(terms,operands)
            if operands[i] == "*":
                newTerms[i] = float(terms[i])*float(terms[i+1])
                del newTerms[i+1]
                del operands[i]
                found += 1
            elif operands[i] == "/":
                newTerms[i] = float(terms[i])/float(terms[i+1])
                del newTerms[i+1]
                del operands[i]
                found += 1
        #print("mult:", newTerms)
        for i in range(0,len(operands)):
            if operands[i] == "-":
                newTerms[i+1] = str((-1)*float(terms[i+1]))
        #print("sub:", newTerms)
        for i in newTerms:
            final += float(i)
    else:
        final = ""
        for i in terms:
            for k in i:
                if k.isdigit() == True or k == "." or k == "-":
                    final += str(k)
        final = float(final)
    #print("solved:", final)
    return(final)

def funcPlugger(depVar, indepVar, equations):
    substitueValues = list(range(10))
    for i in equations:
        for k in substitueValues:
            a = getOperandsAndTerms(i.format(k))
            b = funcSolver(a[0],a[1])
            if depVar == "x":
                print(b,k)
            else:
                print(k,b)
        
#print(funcCombiner("y+x+3=4-2-y"))
#print(getOperandsAndTerms("y + 4 = 3"))
#print(funcCompiler(["x","4","-3","(1)"],["+","*","/"]))
b = "(45*(2+99)(3^6))^3(99-(57/2))"
print(b)
b=getOperandsAndTerms(b)
print(b)
b=prenEliminator(b[0],b[1])
print(b)
#print(b)
#funcPlugger("y","x",b)
#funcPlugger("x","y",b)
#b=getOperandsAndTerms(b)
#print(b)
#print(funcInterpreter(b))
#print(funcInterpreter(b))
#'print(varSplitter(b[0],b[1], ["x","y"]))
#a = getOperandsAndTerms(b)
#print(a[0],a[1])
#print(prenEliminator(a[0],a[1]))
#print("a", a)
#print(funcSolver(a[0],a[1]))
